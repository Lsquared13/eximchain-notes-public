# Solidity Gotchas
Developers who haven't written Solidity before (e.g. nearly all developers) might be surprised by the consequences of their code running in the Ethereum Virtual Machine.  This document gathers examples and links of those problems.

## Optimizing Gas Usage
Most things boil down to optimizing gas usage.  Every operation costs gas, and some operations are very expensive for subtle reasons.

- [**Clearing Arrays**](https://ethereum.stackexchange.com/questions/3373/how-to-clear-large-arrays-without-blowing-the-gas-limit): Resetting an array can be expensive because each element needs its own delete operation.  If you have a dynamically-sized unbounded array (i.e. one that users can arbitrarily add elements to), then the cost of clearing it out can exceed the block gas limit.  In some cases, this leaves the array stuck forever.  The solution in the linked Stack Overflow post is to instead maintain a `liveElements` integer.  When you want to reset, you set `liveElements = 0`.  When you want to iterate over the array, you use `liveElements` instead of `array.length`.  When you want to set an element, you just use `liveElements` as the index.  There are also other solutions described in [the reddit post](https://www.reddit.com/r/ethereum/comments/4ghzhv/governmentals_1100_eth_jackpot_payout_is_stuck/) which originally spawned the SO post, such as multi-transaction clear functions.
- [**Struct Design**](https://medium.com/@novablitz/storing-structs-is-costing-you-gas-774da988895e): Storing data is one of the most expensive parts of every smart contract, so it's important to optimize what we choose to store.  Bringing it back to the days of counting bytes, Solidity's basic types are declared with a size.  `uint`, for example, ranges for `uint8` to `uint256` in increments of 8 bytes.  In the underlying EVM, storage happens in chunks of 32-byte chunks.  When you make a struct which combines multiple variables, it is going to pack all of those variables into as few chunks as possible.  Limiting your variables to the largest values they need to hold reduces the total space required for each struct.  Specifically, any variables which need less than 32 bytes should be declared next to each other so the compiler packs them together.
